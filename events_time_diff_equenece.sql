
with 
-- Fetch the userid, event times and the navigation user events with the date
-- for students and teachers (paying customers only) for a given period
raw_data as (
  select userid,
  eventtime,
  eventsubtype,
  COALESCE(TRY(actor.roles[1]), null) AS roles,
  timestamp,
  concat(day, '-',month,'-',year) AS dt
  FROM ubd_events
    WHERE eventAction = 'NavigatedTo'
            AND eventtype != 'ViewEvent'
            AND LENGTH(eventsubtype) != 0
            -- AND ( actor.roles = array['Learner'] OR actor.roles = array['Instructor'] ) 
            -- AND actor.roles = array['Instructor']
            -- AND actor.roles = array['Learner']
--    AND actor.districtpid NOT LIKE '91%'
  --          AND actor.districtpid NOT LIKE '92%'
    --        AND actor.districtpid NOT LIKE '79%'
      --      AND actor.districtpid NOT LIKE '88%'
            AND target.extensions['autoGenerated'] = 'false'
            AND year = '2019'
            AND month = '08'
  AND day in ('16','17','18','19','20','21','22','23','24','25','26','27','28','29','30')
),
-- Fetch the next event sub type and the next event time based on the userid and date.
-- The next event and time should only be selected per user per day
-- as the session is set to be the whole day
base_data as(
SELECT *,
Lead(eventsubtype, 1) OVER(partition BY userid, dt ORDER BY  eventtime) AS next_event, 
Lead(CAST(to_unixtime(from_iso8601_timestamp(eventtime)) AS BIGINT), 1) OVER(partition BY userid, dt ORDER BY  eventtime) AS next_time
from raw_data
),

big_data as(
-- calculate the time difference between the next event and the current event, to find the time interval between events
select *,
         CASE
         WHEN LENGTH(next_event) > 0 
         THEN date_diff('millisecond',from_iso8601_timestamp(eventtime), Lead(from_iso8601_timestamp(eventtime), 1) OVER(partition BY userid, dt ORDER BY  eventtime))
         ELSE 0
         END AS time_diff,
         COALESCE(TRY(LENGTH(next_event)), 0) AS next_event_len
         from base_data
),
-- Calculate how many hierarchies of an eventsubtype is to be kept
final_data AS 
(
    SELECT userid,
        roles,
-- if the eventsubtype starts with any of the below given events, then limit the event to max 3 hierarchies
-- eg: an event 'datareporting.aaa.bbb.ccc.ddd.fff' will be trimmed to 'datareporting.aaa.bbb'
-- if the event does not belong to the listed ones trim it to 2 hierarchies
-- so an event 'aaa.bbb.ccc.ddd' will be trimmed to 'aaa.bbb'
        CASE
        WHEN regexp_extract(eventsubtype,'^.*?(?=[\.]|$)') IN ('datareporting', 'CreateAssignment', 'StudentAssignmentList', 'AssignmentList', 'ManualScoring') 
        THEN        regexp_extract(eventsubtype,'^.*?([\.]|$).*?([\.]|$).*?(?=\.|$)')
        WHEN regexp_extract(eventsubtype,'^.*?([\.]).*?(?=[\.]|$)') = 'Discover.ModuleCarousel'
        THEN        regexp_extract(eventsubtype,'^.*?(?=$|[\d])')
        ELSE 
        regexp_extract(eventsubtype, '^.*?([\.]|$).*?(?=\.|$)')
        END AS event,
        CASE
        WHEN regexp_extract(next_event,'^.*?(?=[\.]|$)') IN ('datareporting', 'CreateAssignment', 'StudentAssignmentList', 'AssignmentList', 'ManualScoring') 
        THEN  regexp_extract(next_event,'^.*?([\.]|$).*?([\.]|$).*?(?=\.|$)')
        WHEN regexp_extract(eventsubtype,'^.*?([\.]).*?(?=[\.]|$)') = 'Discover.ModuleCarousel'
        THEN regexp_extract(eventsubtype,'^.*?(?=$|[\d])')
        ELSE regexp_extract(next_event, '^.*?([\.]|$).*?(?=\.|$)')
        END AS event_next, time_diff, dt
    FROM big_data
-- select only those events which are not similar to the next event as it would be a double click registered
-- Or if they are similar check the time difference ti be greater than 900ms
-- Only keep the values for which th time difference is in between 500ms and 8280000ms (~23 hrs)
-- Remove all the records which have no next events
    WHERE ( eventsubtype<>next_event OR (eventsubtype = next_event AND time_diff NOT BETWEEN 1 AND 900))
    AND time_diff > 500
    AND time_diff < 8280000
    AND next_event is NOT NULL
    AND next_event_len > 0
),
-- Fetch joined up event sequences with the time differences
aggr_data AS
(
SELECT userid, roles, event,event_next,
concat(event, '->',event_next) AS event_seq,
       time_diff
    from final_data
)
-- Finally select all the unique event links (event1->event2 link) with a list of time intervals for all the users and order the result based on the event sequence
select event_seq,       
       cardinality(array_agg(time_diff)) as totsum,
       array_join(array_agg(time_diff), ',') as arr
FROM aggr_data
GROUP BY event_seq
order by event_seq




------------------------------------------------------









-- Query to generate a list of event sequences and the respective time differences per user per day
with 
-- Fetch the userid, event times and the navigation user events with the date
-- for students and teachers (paying customers only) for a given period
raw_data as (
  select userid,
  eventtime,
  eventsubtype,
  COALESCE(TRY(actor.roles[1]), null) AS roles,
  timestamp,
  concat(day, '-',month,'-',year) AS dt
  FROM ubd_events
    WHERE eventAction = 'NavigatedTo'
            AND eventtype != 'ViewEvent'
            AND LENGTH(eventsubtype) != 0
            AND ( actor.roles = array['Learner'] OR actor.roles = array['Instructor'] ) 
            -- AND actor.roles = array['Instructor']
            -- AND actor.roles = array['Learner']
    AND actor.districtpid NOT LIKE '91%'
            AND actor.districtpid NOT LIKE '92%'
            AND actor.districtpid NOT LIKE '79%'
            AND actor.districtpid NOT LIKE '88%'
            AND target.extensions['autoGenerated'] = 'false'
            AND year = '2019'
            AND month = '04'
    and day in ('01','02')
),
-- Fetch the next event sub type and the next event time based on the userid and date.
-- The next event and time should only be selected per user per day
-- as the session is set to be the whole day
base_data as(
SELECT *,
Lead(eventsubtype, 1) OVER(partition BY userid, dt ORDER BY  eventtime) AS next_event, 
Lead(CAST(to_unixtime(from_iso8601_timestamp(eventtime)) AS BIGINT), 1) OVER(partition BY userid, dt ORDER BY  eventtime) AS next_time
from raw_data
),

big_data as(
-- calculate the time difference between the next event and the current event, to find the time interval between events
select *,
         CASE
         WHEN LENGTH(next_event) > 0 
         THEN date_diff('millisecond',from_iso8601_timestamp(eventtime), Lead(from_iso8601_timestamp(eventtime), 1) OVER(partition BY userid, dt ORDER BY  eventtime))
         ELSE 0
         END AS time_diff,
         COALESCE(TRY(LENGTH(next_event)), 0) AS next_event_len
         from base_data
),
-- Calculate how many hierarchies of an eventsubtype is to be kept
final_data AS 
(
    SELECT userid,
        roles,
-- if the eventsubtype starts with any of the below given events, then limit the event to max 3 hierarchies
-- eg: an event 'datareporting.aaa.bbb.ccc.ddd.fff' will be trimmed to 'datareporting.aaa.bbb'
-- if the event does not belong to the listed ones trim it to 2 hierarchies
-- so an event 'aaa.bbb.ccc.ddd' will be trimmed to 'aaa.bbb'
        CASE
        WHEN regexp_extract(eventsubtype,'^.*?(?=[\.]|$)') IN ('datareporting', 'CreateAssignment', 'StudentAssignmentList', 'AssignmentList', 'ManualScoring') 
        THEN
        regexp_extract(eventsubtype,'^.*?([\.]|$).*?([\.]|$).*?(?=\.|$)')
        ELSE 
        regexp_extract(eventsubtype, '^.*?([\.]|$).*?(?=\.|$)')
        END AS event,
        CASE
        WHEN regexp_extract(next_event,'^.*?(?=[\.]|$)') IN ('datareporting', 'CreateAssignment', 'StudentAssignmentList', 'AssignmentList', 'ManualScoring') 
        THEN
        regexp_extract(next_event,'^.*?([\.]|$).*?([\.]|$).*?(?=\.|$)')
        ELSE regexp_extract(next_event, '^.*?([\.]|$).*?(?=\.|$)')
        END AS event_next, time_diff, dt
    FROM big_data
-- select only those events which are not similar to the next event as it would be a double click registered
-- Or if they are similar check the time difference ti be greater than 900ms
-- Only keep the values for which th time difference is in between 500ms and 8280000ms (~23 hrs)
-- Remove all the records which have no next events
    WHERE ( eventsubtype<>next_event OR (eventsubtype = next_event AND time_diff NOT BETWEEN 1 AND 900))
    AND time_diff > 500
    AND time_diff < 8280000
    AND next_event is NOT NULL
    AND next_event_len > 0
),
-- Fetch joined up event sequences with the time differences
aggr_data AS
(
SELECT userid, roles, event,event_next,
concat(event, '->',event_next) AS event_seq,
       time_diff
    from final_data
)
-- Finally select all the unique event links (event1->event2 link) with a list of time intervals for all the users and order the result based on the event sequence
select event_seq,
       array_join(array_agg(time_diff), ',') as arr
FROM aggr_data
GROUP BY event_seq
order by event_seq


-- --------------------
-- --------------------
-- --------------------
-- --------------------
-- Query to fetch percentage usage data
with raw_data AS 
    (SELECT userid,
         eventtime,
         CASE
        WHEN regexp_extract(eventsubtype,'^.*?(?=[\.]|$)') IN ('datareporting', 'CreateAssignment', 'StudentAssignmentList', 'AssignmentList', 'ManualScoring') 
        THEN
        regexp_extract(eventsubtype,'^.*?([\.]|$).*?([\.]|$).*?(?=\.|$)')
        ELSE 
        regexp_extract(eventsubtype, '^.*?([\.]|$).*?(?=\.|$)')
        END AS eventsubtype,
         -- COALESCE(TRY(actor.roles[1]), null) AS roles,    
     CAST(1 AS BIGINT) AS seq, timestamp, 
     concat(day, '-',month,'-',year) AS dt
    FROM ubd_events
    WHERE eventAction = 'NavigatedTo'
            AND eventtype != 'ViewEvent'
            AND LENGTH(eventsubtype) != 0
            AND ( actor.roles = array['Learner']
            OR actor.roles = array['Instructor'] ) 
            -- AND actor.roles = array['Instructor']
            -- AND actor.roles = array['Learner']
            AND actor.districtpid NOT LIKE '91%'
            AND actor.districtpid NOT LIKE '92%'
            AND actor.districtpid NOT LIKE '79%'
            AND actor.districtpid NOT LIKE '88%'
            AND target.extensions['autoGenerated'] = 'false'
            AND year = '2019'
            AND month = '04'
            AND day = '01'
            -- AND hour = '14'
    ),
base_data as
    (
      SELECT *,
         Lead(eventsubtype,1) OVER(partition BY userid, dt ORDER BY  eventtime) AS next_event
    FROM raw_data 
      ),
d1 as (
    select userid, eventtime, concat(eventsubtype,' -> ',next_event) as events,
     dt, seq
    from base_data
    where next_event is not null
  ),
d2 as (
select sum(seq) as totsum
       from d1
  ),
d3 AS (
select events as allevents, sum(d1.seq) AS sumev, d2.totsum as totalsum
from d1,d2
group by events,d2.totsum
)
select allevents, sumev, totalsum, round((CAST(sumev AS DOUBLE)/CAST(totalsum AS DOUBLE))*100,4) as perc
from d3
order by perc desc